<<<<<<< HEAD
SOLID principles
	# гарантируют, что программу будет проще дополнять, тратить меньше денег, будет разрастаться контролируемо, легко дебажить, возможности для добавления необходимой функциональности.
		
Single responsibility principle,  
    принцип единственной ответственности (роберт мартин clean code, Macconell)
		# Каждый объект должен иметь обязанность и эта обязанность должна быть инкапсулирована в класс
		# класс должен иметь только те поля и методы, которые относятся ТОЛЬКО к ОДНОМУ вопросу!!!
		# каждый класс должен использоваться для выполнения ОДНОЙ задачи! 

Open–closed principle,
		# программные сущности должны быть открыты для расширения, но закрыты для изменения
		# любой блок должен иметь возможность для добавления функциональности, но при этом старый код менять нельзя, кроме баг-фиксов! во избежание новых багов, ошибок
		# можем применять наследование, полиморфизм
		# клиентский код должен зависить от интерфейсов, не меняя клиентский код (майер, роберт мартин clean code)

Liskov substitution principle,  
    Принцип подстановки Барбары Лисков
		# Принцип определяет, что объекты класса-родителя должны быть заменены объектами его подклассов без нарушения работы приложения. Это требует, чтобы объекты ваших подклассов вели себя так же, как объекты вашего класса-родителя (предка). Вы можете добиться этого, следуя нескольким правилам, которые очень похожи на концепцию «проектирование по контракту», определенную Бертраном Мейером.

    # Переопределенный метод подкласса должен принимать те же значения входных параметров, что и метод класса-родителя (предка). Это означает, что можно реализовать менее строгие правила проверки, но нельзя применять более строгие в своем sub-классе. В противном случае любой код,вызывающий этот метод для объекта класса-родителя (предка), может вызвать исключение, если он вызывается с объектом подкласса.

    # Аналогичные правила применяются к возвращаемому значению метода. Возвращаемое значение метода подкласса должно соответствовать тем же правилам, что и возвращаемое значение метода класса-родителя (предка). Вы можете решить применить еще более строгие правила, только вернув определенный подкласс определенного возвращаемого значения или вернув подмножество допустимых возвращаемых значений класса-родителя (предка).

Interface segregation principle,
    Принцип разделения интерфейсов - Клиенты не должны зависеть от интерфейсов, которые они не используют.
    - Подобно принципу единой ответственности, цель принципа разделения интерфейсов - уменьшить побочные эффекты и частоту требуемых изменений путем разделения программного обеспечения на несколько независимых частей.
    - Архитектурный стиль микросервисов повысил важность этого принципа.
    - Внедрение каждого изменения сопряжено с риском. Для снижения риска можно добавить интерфейс, который будет отвечать за одну задачу
    
Dependency inversion principle,
    Принцип инверсии зависимостей, 
    - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
=======
SOLID principles
	# гарантируют, что программу будет проще дополнять, тратить меньше денег, будет разрастаться контролируемо, легко дебажить, возможности для добавления необходимой функциональности.
		
Single responsibility principle,  
    принцип единственной ответственности (роберт мартин clean code, Macconell)
		# Каждый объект должен иметь обязанность и эта обязанность должна быть инкапсулирована в класс
		# класс должен иметь только те поля и методы, которые относятся ТОЛЬКО к ОДНОМУ вопросу!!!
		# каждый класс должен использоваться для выполнения ОДНОЙ задачи! 

Open–closed principle,
		# программные сущности должны быть открыты для расширения, но закрыты для изменения
		# любой блок должен иметь возможность для добавления функциональности, но при этом старый код менять нельзя, кроме баг-фиксов! во избежание новых багов, ошибок
		# можем применять наследование, полиморфизм
		# клиентский код должен зависить от интерфейсов, не меняя клиентский код (майер, роберт мартин clean code)

Liskov substitution principle,  
    Принцип подстановки Барбары Лисков
		# Принцип определяет, что объекты класса-родителя должны быть заменены объектами его подклассов без нарушения работы приложения. Это требует, чтобы объекты ваших подклассов вели себя так же, как объекты вашего класса-родителя (предка). Вы можете добиться этого, следуя нескольким правилам, которые очень похожи на концепцию «проектирование по контракту», определенную Бертраном Мейером.

    # Переопределенный метод подкласса должен принимать те же значения входных параметров, что и метод класса-родителя (предка). Это означает, что можно реализовать менее строгие правила проверки, но нельзя применять более строгие в своем sub-классе. В противном случае любой код,вызывающий этот метод для объекта класса-родителя (предка), может вызвать исключение, если он вызывается с объектом подкласса.

    # Аналогичные правила применяются к возвращаемому значению метода. Возвращаемое значение метода подкласса должно соответствовать тем же правилам, что и возвращаемое значение метода класса-родителя (предка). Вы можете решить применить еще более строгие правила, только вернув определенный подкласс определенного возвращаемого значения или вернув подмножество допустимых возвращаемых значений класса-родителя (предка).

Interface segregation principle,
    Принцип разделения интерфейсов - Клиенты не должны зависеть от интерфейсов, которые они не используют.
    - Подобно принципу единой ответственности, цель принципа разделения интерфейсов - уменьшить побочные эффекты и частоту требуемых изменений путем разделения программного обеспечения на несколько независимых частей.
    - Архитектурный стиль микросервисов повысил важность этого принципа.
    - Внедрение каждого изменения сопряжено с риском. Для снижения риска можно добавить интерфейс, который будет отвечать за одну задачу
    
Dependency inversion principle,
    Принцип инверсии зависимостей, 
    - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
>>>>>>> refs/remotes/origin/readme
    - Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.